// Generated by CoffeeScript 1.7.1
(function() {
  var Client, LoggerWrap, RedisSentinelClient, RedisSingleClient, RollArray, commands, events, reply_to_object, to_array, util,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  RedisSingleClient = require('gf-redis');

  events = require('events');

  util = require('util');

  reply_to_object = require('redis/lib/util.js').reply_to_object;

  to_array = require('redis/lib/to_array.js');

  commands = require('redis/lib/commands');

  RollArray = (function() {
    function RollArray(arr) {
      this.setData(arr);
    }

    RollArray.prototype.setData = function(arr) {
      var item, _i, _len;
      this.arr = [];
      if (arr) {
        for (_i = 0, _len = arr.length; _i < _len; _i++) {
          item = arr[_i];
          this.arr.push(item);
        }
      }
      return this;
    };

    RollArray.prototype.next = function() {
      var item;
      if (this.arr.length === 0) {
        return null;
      }
      item = this.arr.shift();
      this.arr.push(item);
      return item;
    };

    return RollArray;

  })();

  LoggerWrap = (function() {
    function LoggerWrap(logger) {
      this.logger = logger;
      this.fetal = __bind(this.fetal, this);
      this.error = __bind(this.error, this);
      this.warn = __bind(this.warn, this);
      this.info = __bind(this.info, this);
      this.debug = __bind(this.debug, this);
    }

    LoggerWrap.prototype.debug = function(obj) {
      if (this.logger && this.logger.debug) {
        return this.logger.debug(obj);
      }
    };

    LoggerWrap.prototype.info = function(obj) {
      if (this.logger && this.logger.info) {
        return this.logger.info(obj);
      }
    };

    LoggerWrap.prototype.warn = function(obj) {
      if (this.logger && this.logger.warn) {
        return this.logger.warn(obj);
      }
    };

    LoggerWrap.prototype.error = function(obj) {
      if (this.logger && this.logger.error) {
        return this.logger.error(obj);
      }
    };

    LoggerWrap.prototype.fetal = function(obj) {
      if (this.logger && this.logger.fetal) {
        return this.logger.fetal(obj);
      }
    };

    return LoggerWrap;

  })();

  Client = (function(_super) {
    __extends(Client, _super);

    function Client(name, role, options) {
      this.name = name;
      this.role = role;
      this.options = options;
      this.onClientError = __bind(this.onClientError, this);
      this.onClientReconnecting = __bind(this.onClientReconnecting, this);
      this.onClientEnd = __bind(this.onClientEnd, this);
      this.onClientConnect = __bind(this.onClientConnect, this);
      this.connect = __bind(this.connect, this);
      this.isSameServer = __bind(this.isSameServer, this);
      this.getPort = __bind(this.getPort, this);
      this.getHost = __bind(this.getHost, this);
      this.getRole = __bind(this.getRole, this);
      this.getName = __bind(this.getName, this);
      this.getId = __bind(this.getId, this);
      this.getStatus = __bind(this.getStatus, this);
      this.disconnect = __bind(this.disconnect, this);
      this.id = "" + this.name + "-" + this.role;
      this.client = null;
      this.logger = this.options.logger;
      this.status = "disconnect";
      this.timeoutClock = null;
      this.pingClock = null;
      this.firstConnect = true;
    }

    Client.prototype.disconnect = function() {
      if (this.client) {
        this.logger.info("" + this.id + " disconnect " + this.host + ":" + this.port);
        this.client.end();
        this.client = null;
        if (this.status === "connected") {
          this.emit("end");
        }
      }
      this.host = null;
      this.port = null;
      this.status = "disconnect";
      if (this.pingClock) {
        clearInterval(this.pingClock);
        return this.pingClock = null;
      }
    };

    Client.prototype.getStatus = function() {
      return this.status;
    };

    Client.prototype.getId = function() {
      return this.id;
    };

    Client.prototype.getName = function() {
      return this.name;
    };

    Client.prototype.getRole = function() {
      return this.role;
    };

    Client.prototype.getHost = function() {
      return this.host;
    };

    Client.prototype.getPort = function() {
      return this.port;
    };

    Client.prototype.isSameServer = function(host, port) {
      return this.host === host && this.port === port;
    };

    Client.prototype.connect = function(host, port) {
      var client, self;
      if (this.host === host && this.port === port && this.status !== "disconnect") {
        this.logger.info("" + this.id + " is " + this.status + " " + host + ":" + port + ",return");
        return;
      }
      this.disconnect();
      this.host = host;
      this.port = port;
      this.logger.info("" + this.id + " try to connect " + this.host + ":" + this.port);
      this.client = new RedisSingleClient.createClient(this.port, this.host, this.options);
      this.status = "connecting";
      this.emit("connecting");
      this.client.on("connect", this.onClientConnect.bind(this));
      this.client.on("error", this.onClientError.bind(this));
      this.client.on("end", this.onClientEnd.bind(this));
      this.client.on("reconnecting", this.onClientReconnecting.bind(this));
      this.errorTimes = 0;
      client = this.client;
      self = this;
      return ['message', 'pmessage', 'unsubscribe', 'end', 'reconnecting', 'ready', 'subscribe'].forEach(function(evt) {
        return client.on(evt, function() {
          if (self.client === client) {
            return self.emit.apply(self, [evt].concat(Array.prototype.slice.call(arguments)));
          }
        });
      });
    };

    Client.prototype.onClientConnect = function() {
      var pingFun, self;
      this.status = "connected";
      this.logger.info("" + this.id + " success connect " + this.host + ":" + this.port);
      this.errorTimes = 0;
      this.emit("connect", this.id);
      if (this.firstConnect) {
        this.emit("firstconnect", this.id);
        this.firstConnect = false;
      } else {
        this.emit("reconnect", this.id);
      }
      if (!this.pingClock) {
        self = this;
        pingFun = function() {
          return self.client.ping(function(err, d) {
            if (err) {
              return self.logger.error("client " + self.id + " ping " + self.host + ":" + self.port + " error:" + err);
            }
          });
        };
        return this.pingClock = setInterval(pingFun, this.options.pingTime);
      }
    };

    Client.prototype.onClientEnd = function() {
      this.status = "disconnect";
      this.logger.info("" + this.id + " disconnect " + this.host + ":" + this.port);
      this.errorTimes = 0;
      if (this.pingClock) {
        clearInterval(this.pingClock);
        this.pingClock = null;
      }
      return this.emit("end");
    };

    Client.prototype.onClientReconnecting = function() {
      this.status = "connecting";
      this.logger.info("" + this.id + " reconnecting " + this.host + ":" + this.port);
      return this.emit("reconnecting");
    };

    Client.prototype.onClientError = function(error) {
      this.logger.error("" + this.id + " " + this.host + ":" + this.port + " error:" + error);
      this.errorTimes++;
      if (this.errorTimes > 3) {
        this.disconnect();
        this.emit("reconnectClient", this.name);
        return this.errorTimes = 0;
      }
    };

    Client.prototype.timeoutReconnect = function() {
      var fun, self;
      if (this.timeoutClock) {
        return;
      }
      self = this;
      fun = function() {
        this.timeoutClock = null;
        return self.emit("reconnectClient", self.name);
      };
      return this.timeoutClock = setTimeout(fun, self.options.noSlaveReconnectTime);
    };

    return Client;

  })(events.EventEmitter);

  commands.forEach(function(command) {
    return Client.prototype[command.toUpperCase()] = Client.prototype[command] = function(args, callback) {
      var cb, fn, len;
      if (this.status !== "connected") {
        len = arguments.length;
        cb = arguments[len - 1];
        if (typeof cb === "function") {
          cb("client is not connected," + this.status);
        }
      }
      fn = this.client[command];
      return fn.apply(this.client, arguments);

      /*
      if Array.isArray(args) and typeof callback == "function"
          return @client.send_command(command, args, callback)
      else
          return @client.send_command(command, to_array(arguments))
       */
    };
  });


  /*
  {
      clients:[
          {
              "role":"master",   //slave
              "name":"master86"
          }
      ],
      sentinels:[
          {
              "host":"x.x.x.x",
              "port":5678
          }
      ],
      logger:
  }
   */

  RedisSentinelClient = (function(_super) {
    __extends(RedisSentinelClient, _super);

    function RedisSentinelClient(options) {
      this._reconnectClient = __bind(this._reconnectClient, this);
      this._disconnectClient = __bind(this._disconnectClient, this);
      this.getClient = __bind(this.getClient, this);
      this._checkClientHostAndPort = __bind(this._checkClientHostAndPort, this);
      this._connectSentinel = __bind(this._connectSentinel, this);
      this.reconnectSentinel = __bind(this.reconnectSentinel, this);
      var arr, c, cOptions, client, cs, id, s, _i, _j, _len, _len1, _ref, _ref1;
      this.logger = new LoggerWrap(options.logger);
      this.talkSentinel = null;
      this.talkSentinelStatus = "disconnect";
      this.subSentinel = null;
      this.subSentinelStatus = "disconnect";
      if (options.master_debug) {
        RedisSingleClient.debug_mode = true;
      }
      this.talkSentinelPingTime = options.talkSentinelPingtime || 2000;
      this.checkClientTime = options.checkClientTime || 20000;
      this.noMasterPartnerSentinelReconnectTime = options.noMasterPartnerSentinelReconnectTime || 3000;
      this.clients = {};
      cOptions = {
        logger: this.logger,
        pingTime: options.clientPingTime || 2000,
        noSlaveReconnectTime: options.clientNoSlaveReconnectTime || 3000
      };
      _ref = options.clients;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        client = new Client(c.name, c.role, cOptions);
        id = client.getId();
        this.logger.info("create client,id=" + id);
        cs = this.clients[c.name];
        if (!cs) {
          cs = [];
          this.clients[c.name] = cs;
        }
        cs.push(client);
        client.on("reconnectClient", this._reconnectClient.bind(this));
      }
      this.sentinels = new RollArray();
      arr = [];
      _ref1 = options.sentinels;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        s = _ref1[_j];
        arr.push({
          host: s.host,
          port: s.port
        });
      }
      this.sentinels.setData(arr);
      this.reconnectSentinel();
      this.on('subSentinel disconnected', this.reconnectSentinel.bind(this));
      this.on('talkSentinel disconnected', this.reconnectSentinel.bind(this));
      this.on('change sentinel', this.reconnectSentinel.bind(this));
      this.on('failover start', this._disconnectClient.bind(this));
      this.on('switch master', this._reconnectClient.bind(this));
      this.on('change slave', this._reconnectClient.bind(this));
      this.on('check sentinel', this.reconnectSentinel.bind(this));
    }

    RedisSentinelClient.prototype.reconnectSentinel = function() {
      var sentinel;
      this.logger.info("reconnectSentinel");
      if (this.talkSentinel) {
        this.talkSentinel.end();
        this.talkSentinel = null;
      }
      this.talkSentinelStatus = "disconnect";
      if (this.subSentinel) {
        this.subSentinel.end();
        this.subSentinel = null;
      }
      this.subSentinelStatus = "disconnect";
      sentinel = this.sentinels.next();
      this.logger.info("use sentinel " + sentinel.host + ":" + sentinel.port);
      return this._connectSentinel(sentinel);
    };

    RedisSentinelClient.prototype._connectSentinel = function(sentinel) {
      var host, logger, port, self;
      host = sentinel.host;
      port = sentinel.port;
      self = this;
      logger = this.logger;
      logger.info("_connectSentinel " + host + ":" + port);
      logger.info("talkSentinel try to connect to sentinel " + host + ":" + port);
      this.talkSentinel = new RedisSingleClient.createClient(port, host);
      this.talkSentinelStatus = "connecting";
      this.talkSentinel.on('connect', function() {
        var fun, pingFun;
        logger.info("talkSentinel success connect sentinel " + host + ":" + port);
        self.talkSentinelStatus = "connected";
        self.emit('talkSentinel connected', sentinel);
        self._checkClientHostAndPort();
        if (!self.talkSentinelPingClock) {
          pingFun = function() {
            return self.talkSentinel.ping(function(err) {
              if (err) {
                return logger.error("talkSentinel ping " + host + ":" + port + " error:" + err);
              }
            });
          };
          self.talkSentinelPingClock = setInterval(pingFun, self.talkSentinelPingTime);
        }
        if (!self.checkClientJobClock) {
          fun = self._checkClientJob.bind(self);
          return self.checkClientJobClock = setInterval(fun, self.checkClientTime);
        }
      });
      this.talkSentinel.on('error', function(err) {
        logger.error("talkSentinel error:" + err.message + " at " + host + ":" + port);
        return self.emit('talkSentinel error', err);
      });
      this.talkSentinel.on('end', function() {
        logger.error("talkSentinel end at " + host + ":" + port);
        self.talkSentinelStatus = "disconnect";
        self.emit('talkSentinel disconnected');
        if (self.talkSentinelPingClock) {
          clearInterval(self.talkSentinelPingClock);
          self.talkSentinelPingClock = null;
        }
        if (self.checkClientJobClock) {
          clearInterval(self.checkClientJobClock);
          return self.checkClientJobClock = null;
        }
      });
      logger.info("subSentinel try to connect to sentinel " + host + ":" + port);
      this.subSentinel = new RedisSingleClient.createClient(port, host);
      this.subSentinelStatus = "connecting";
      this.subSentinel.on('connect', function() {
        logger.info("subSentinel success connect sentinel " + host + ":" + port);
        self.subSentinelStatus = "connected";
        self.emit('subSentinel connected', sentinel);
        return self._checkClientHostAndPort();
      });
      this.subSentinel.on('error', function(err) {
        logger.error("subSentinel error:" + err.message + " at " + host + ":" + port);
        return self.emit('subSentinel error', err);
      });
      this.subSentinel.on('end', function() {
        logger.error("subSentinel end at " + host + ":" + port);
        self.subSentinelStatus = "disconnect";
        return self.emit('subSentinel disconnected');
      });
      this.subSentinel.psubscribe("*");
      return this.subSentinel.on("pmessage", function(channel, msg, args) {
        var arr, masterName, roleName, roleNmae;
        logger.info("sentinel message:channel=" + channel + ",msg=" + msg + ",args=" + args);
        self.emit("sentinel message", msg);
        if (msg === "+try-failover") {
          masterName = args.split(" ")[1];
          logger.info("failover detected for " + masterName);
          return self.emit("failover start", masterName);
        } else if (msg === "+switch-master") {
          masterName = args.split(" ")[0];
          logger.info("switch master detected for " + masterName);
          self.emit("failover end", masterName);
          return self.emit('switch master', masterName);
        } else if (msg === "+slave") {
          masterName = args.split(" ")[5];
          logger.info("add slave detected for " + masterName);
          return self.emit('change slave', masterName);
        } else if (msg === "+sdown" || msg === "-sdown") {
          arr = args.split(" ");
          roleName = arr[0];
          masterName = "";
          if (roleName === "slave") {
            masterName = arr[5];
          } else if (roleNmae = "master") {
            masterName = arr[1];
          }
          logger.info("" + msg + " detected for " + masterName + "," + roleName);
          if (roleName === "slave") {
            return self.emit('change slave', masterName);
          } else if (roleName === "sentinel") {
            return self.emit('check sentinel');
          }
        } else if (msg === "+role-change" || msg === "-role-change") {
          arr = args.split(" ");
          roleName = arr[0];
          masterName = "";
          masterName = arr[5];
          logger.info("" + msg + " detected for " + masterName + "," + roleName);
          if (roleName === "slave") {
            return self.emit('change slave', masterName);
          }
        }
      });
    };

    RedisSentinelClient.prototype._checkClientHostAndPort = function() {
      var k, logger, v, _ref, _results;
      if (!this.firstCheckClientHostAndPort) {
        this.firstCheckClientHostAndPort = true;
        this.emit("connect");
      }
      logger = this.logger;
      logger.info("_checkClientHostAndPort,subSentinelStatus=" + this.subSentinelStatus + ",talkSentinelStatus=" + this.talkSentinelStatus);
      if (this.subSentinelStatus !== "connected") {
        logger.info("subSentinel status is not connected,status=" + this.subSentinelStatus);
        return;
      }
      if (this.talkSentinelStatus !== "connected") {
        logger.info("talkSentinel status is not connected,status=" + this.talkSentinelStatus);
        return;
      }
      logger.info("begin checkClientHostAndPort");
      _ref = this.clients;
      _results = [];
      for (k in _ref) {
        v = _ref[k];
        _results.push(this._reconnectClient(k));
      }
      return _results;
    };

    RedisSentinelClient.prototype._checkClientJob = function() {
      var k, v, _ref, _results;
      this.logger.debug("_checkClientJob start");
      if (this.subSentinelStatus !== "connected") {
        return;
      }
      if (this.talkSentinelStatus !== "connected") {
        return;
      }
      _ref = this.clients;
      _results = [];
      for (k in _ref) {
        v = _ref[k];
        _results.push(this._reconnectClient(k, true));
      }
      return _results;
    };

    RedisSentinelClient.prototype.getClient = function(master, role) {
      var client, clients, _i, _len;
      if (role == null) {
        role = "master";
      }
      clients = this.clients[master];
      if (!clients || clients.length === 0) {
        return null;
      } else {
        for (_i = 0, _len = clients.length; _i < _len; _i++) {
          client = clients[_i];
          if (client.getName() === master && client.getRole() === role) {
            return client;
          }
        }
        return null;
      }
    };

    RedisSentinelClient.prototype._disconnectClient = function(master) {
      var clients, logger;
      logger = this.logger;
      clients = this.clients[master];
      if (!clients || clients.length === 0) {
        logger.info("clients is empty");
        return;
      }
      return clients.forEach(function(client) {
        return client.disconnect();
      });
    };

    RedisSentinelClient.prototype._reconnectClient = function(master, checkOnly) {
      var clients, logger, self, talkSentinel;
      if (checkOnly == null) {
        checkOnly = false;
      }
      logger = this.logger;
      if (checkOnly) {
        logger.debug("checkClient " + master);
      } else {
        logger.info("_reconnectClient:" + master);
      }
      if (this.talkSentinelStatus !== "connected") {
        logger.warn("talkSentinel not connected,return ");
        return;
      }
      talkSentinel = this.talkSentinel;
      clients = this.clients[master];
      if (!clients || clients.length === 0) {
        logger.info("clients is empty");
        return;
      }
      self = this;
      return clients.forEach(function(client) {
        var masterName, role;
        masterName = client.getName();
        role = client.getRole();
        if (role === "master") {
          return talkSentinel.send_command("SENTINEL", ["get-master-addr-by-name", masterName], function(err, arr) {
            var e, host, port;
            if (err) {
              return logger.error("error when get-master-addr-by-name for " + masterName + ":" + err);
            } else {
              try {
                host = arr[0];
                port = arr[1];
                if (!host || !port) {
                  logger.error("no master for " + masterName + ",disconnect,reply=" + arr);
                  client.disconnect();
                  client.timeoutReconnect();
                  return;
                }
                if (!(checkOnly && client.isSameServer(host, port))) {
                  client.connect(host, port);
                }
                return talkSentinel.send_command("SENTINEL", ['sentinels', masterName], function(err, arr) {
                  var aa, findSentinel, fun, i, server, _i, _len;
                  if (err) {
                    return logger.error("error when get sentinels for " + masterName + ":" + err);
                  } else {
                    if (arr === null || arr.length === 0) {
                      return logger.warn("sentinel for " + masterName + " is just one");
                    } else {
                      findSentinel = false;
                      for (_i = 0, _len = arr.length; _i < _len; _i++) {
                        aa = arr[_i];
                        i = 0;
                        server = {};
                        while (i < aa.length) {
                          server[aa[i]] = aa[i + 1];
                          i += 2;
                        }
                        if (server['flags'] === 'sentinel') {
                          findSentinel = true;
                          break;
                        }
                      }
                      if (findSentinel === false) {
                        logger.error("sentinel for " + masterName + " no partner sentinel is ok,reconnect sentinel");
                        fun = function() {
                          return self.emit("change sentinel");
                        };
                        return setTimeout(fun, self.noMasterPartnerSentinelReconnectTime);
                      }
                    }
                  }
                });
              } catch (_error) {
                e = _error;
                return logger.error("unable get master for " + masterName + ",reply=" + arr + ",err=" + e + "," + e.stack);
              }
            }
          });
        } else if (role === "slave") {
          return talkSentinel.send_command("SENTINEL", ["slaves", masterName], function(err, arr) {
            var aa, e, host, i, index, port, server, servers, slave, _i, _j, _len, _len1;
            if (err) {
              return logger.error("error when slaves for " + masterName + ":" + err);
            } else {
              try {
                if (arr === null || arr.length === 0) {
                  logger.error("no slave for " + masterName + ",disconnect");
                  client.disconnect();
                  return client.timeoutReconnect();
                } else {
                  servers = [];
                  for (_i = 0, _len = arr.length; _i < _len; _i++) {
                    aa = arr[_i];
                    i = 0;
                    server = {};
                    while (i < aa.length) {
                      server[aa[i]] = aa[i + 1];
                      i += 2;
                    }
                    if (server['flags'] === 'slave') {
                      servers.push(server);
                    }
                  }
                  if (servers.length === 0) {
                    logger.error("no slave status is ok for " + masterName + ",disconnect");
                    client.disconnect();
                    client.timeoutReconnect();
                    return;
                  }
                  if (checkOnly) {
                    for (_j = 0, _len1 = servers.length; _j < _len1; _j++) {
                      server = servers[_j];
                      if (client.isSameServer(server['ip'], server['port'])) {
                        return;
                      }
                    }
                  }
                  index = Math.floor(Math.random() * servers.length);
                  slave = servers[index];
                  host = slave['ip'];
                  port = slave['port'];
                  return client.connect(host, port);
                }
              } catch (_error) {
                e = _error;
                return logger.error("unable get slave for " + masterName + ",reply=" + arr + ",err=" + e + "," + e.stack);
              }
            }
          });
        } else {
          throw new Error("unknow role for master=" + masterName + ",role=" + role);
        }
      });
    };

    return RedisSentinelClient;

  })(events.EventEmitter);

  module.exports.RedisSentinelClient = RedisSentinelClient;

  module.exports.createClient = function(options) {
    return new RedisSentinelClient(options);
  };

}).call(this);
